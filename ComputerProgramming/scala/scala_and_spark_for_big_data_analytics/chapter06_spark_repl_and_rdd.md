# 6장 스파크로 REPL과 RDD 작업
스파크의 동작 방법을 다룬다.
스파크의 기본 추상화인 RDD에 대해 소개하며, 스칼라와 유사한 API를 제공하는 분산 컬렉션도 살펴본다.

6장에서 다루는 내용
* 스파크에 대해 깊이 살펴보기
* 스파크 설치
* RDD 소개
* 스파크 셸 사용
* 트랜스포메이션과 액션
* 캐싱
* 데이터 로드와 저장

## 스파크에 대해 깊게 살펴보기
* 스파크 구성
  * 스파크 코어
  * 관련 라이브러리

* 스파크 주요 컴포넌트
  * 드라이버(Driver)
    * 애플리케이션, main 프로그램이 들어 있다.드라이버는 클러스터에 익스큐터를 시작시키고 태스크 실행을 제어한다.
  * 익스큐터(Executor)
    * 클러스터의 워커 노드에서 실행중인 프로세스다. 익스큐터 내부에서 개발 태스크나 계산이 실행된다. 각 워커 노드에 하나 이상의 익스큐터가 존재할 수 있고, 비슷하게 각 익스큐터 내에 여러 태스크가 존재할 수 있다.

* **클러스터 관리자**는 클러스터를 구성하는 계산 노드 전체에 대해 자원 예약과 자원 할당을 담당한다.
  * Standalone(local), 얀, 메소스, 쿠버네티스가 될 수 있다.

* 스파크 프로그램의 주요 진입점은 SparkContext다.
  * SparkContext는 드라이버 컴포넌트 내부에 있으며, 스케줄러, 태스크 배포, 조정을 실행하는 코드와 함께 클러스터에 대한 커넥션을 의미한다.

> TIP

    스파크 2.x에서 SparkSession이라는 새로운 변수가 도입됐다. SparkContext, SQLContext, HiveContext는 이제 SparkSession의 멤버 변수다.

* **드라이버(Driver)** 프로그램을 시작하면 커맨드는 SparkContext를 통해 클러스터에 전달되고, 여러 익스큐터(Executor)에서 해당 잡을 실행한다.

> TIP

    하둡 프레임워크의 모든 MapReduce 잡 또는 하이브(Hive) 쿼리 또는 피그(Pig) 스크립트는 메모리를 사용하는 대신 시간이 많이 걸리는 디스크를 사용한다. 따라서 실행에야 할 각 태스크를 처음부터 모두 처리한다. 그러나 스파크 아키텍처에서는 SparkContext를 유지하고 재사용한다.


## 아파치 스파크 설치
스파크는 크로스플랫폼 프레임워크이다.

* 사전 요구사항
  * (필수) 자바 8이상
  * (선택) 파이썬 3.4이상
  * (선택) R 3.1이상
  * (선택) 스칼라 2.11 이상

* 스파크는 세 가지 기본 배포 모드로 배포할 수 있다.
  * 독립형 스파크
  * 얀 기반의 스파크
  * 메소스 기반의 스파크

### 스파크 독립형 

* 로컬 장비의 기본 셸
  * ./bin/spark-shell
* n개의 스레드를 가진 로컬 장비를 마스터로 지정하는 로컬 장비의 기본 셸
  * ./bin/spark-shell --master local[n]
* 지정된 스파크 마스터에 연결하는 로컬 장비의 기본 셸은 다음과 같다.
  * ./bin/spark-shell --master spark://<IP>:<포트>
* 클라이언트 모드를 사용해 얀 클러스터에 연결하는 로컬 장비의 기본 셸은 다음과 같다.
  * ./bin/spark-shell --master yarn --deploy-mode client
* 클러스터 모드를 사용해 얀 클러스터에 연결하는 로컬 장비의 기본 셸은 다음과 같다.
  * ./bin/spark-shell --master yarn --deploy-mode cluster


스파크 드라이버의 웹 UI URL
http://127.0.0.1:4040/jobs/


### 얀 기반의 스파크
얀(YARN) 모드의 클라이언트는 얀 자원 관리자와 통신하고 스파크를 실행할 수 있는 컨테이너를 얻는다.

* 얀을 사용해 실행하는 경우 스파크는 다음의 2가지 모드로 실행할 수 있다.
  * 얀 클라이언트 모드
  * 얀 클러스터 모드

#### 얀 클라이언트 모드

#### 얀 클러스터 모드
셸은 사용하지 못한다.


### 메소스 기반의 스파크
스파크 독립형 모드와 비슷해서 드라이버는 메소스 마스터와 통신하고 익스큐터를 실행하는데 필요한 자원을 할당한다.


### 쿠버네티스 기반 스파크
* 사전 요구사항
  * 스파크 2.3
  * 쿠버네티스 1.6이상, 쿠버네티스 DNS 기능이 활성화돼야 한다.


## RDD 소개
* RDD(Resilient Distributed Dataset)는 불변이며, 분산 컬렉션 객체다.
* 스파크 RDD는 복원력이 뛰어나고 내결함성이 있어 스파크에서 장애가 밸생할 때 RDD를 복구할 수 있다.
* 불변성 특성 때문에 한번 생성된 RDD는 읽기 전용이다.
* 트랜스포메이션(transformation)은 RDD에서 새로운 RDD를 생성할 수는 있지만, 원본 RDD는 생성된 후에는 결코 수정되지 않는다.
* 이로 인해 RDD는 경쟁 조건과 기타 동기화 문제에 영향을 받지 않는다.
* RDD는 데이터에 대한 참조만 포함하기 때문에(반면 실제 데이터는 클러스터의 노드에 있는 파티션에 포함돼 있다) RDD의 분산 특성이 동작할 수 있다.

> TIP

    개념적으로 RDD는 클러스터의 여러 노드에 걸쳐 존재하는 분산 엘리먼트 컬렉션이다. RDD를 여러 장비에 분산된 대규모 정수 배열로 생각한다면 잘 이해할 수 있을 것이다.

* 내부적으로 각 RDD는 다음과 같은 5가지 주요 속성을 갖고 있다.
  * 파티션 목록
  * 각 파티션을 계산하는 함수
  * 다른 RDD를 의존하는 리스트
  * 선택적으로 키-값 RDD에 대한 파티셔너(예, RDD가 해시로 파티셔닝됨)
  * 선택적으로 각 파티션을 계산하는 기본 위치 리스트(예, HDFS 파일의 블록 위치)

### RDD 생성

* RDD 생성 방법
  * 컬렉션 병렬화 
  * 외부 소스에서 데이터 로드
  * 기존 RDD의 트랜스포메이션
  * 스트리밍 API

#### 컬렉션 병렬화
드라이버 프로그램에서 컬렉션에 parallelize함수를 호출해 프로그램을 수행하는 것을 말한다.

#### 외부 소스에서 데이터 로드
일반적으로 스파크는 최대한 많은 데이터를 가능한 한 메모리에 RDD로 저장하기 위해 최선을 다한다.

#### 기존 RDD에 대한 트랜스포메이션
필터 함수는 트랜스포메이션의 대표적인 예다.

#### 스트리밍 API


## 스파크 셸의 사용
* 스칼라 셸과 유사하다.
* 스칼라 API를 지원한다.


## 트랜스포메이션과 액션
* RDD에서 수행할 수 있는 두 가지 주요 연산
  * 트랜스포메이션(transformation)
  * 액션(action)

* **트랜스포메이션**은 입력 엘리먼트 분리, 엘리먼트 필터링, 일종의 계산 수행과 같은 RDD 엘리먼트를 변경한다.
  * 시퀀스에서 여러 트랜스포메이션을 수행할 수 있다.
  * 그러나 트랜스포메이션은 계획 중에는 실행이 일어나지 않는다.

> Info

    트랜스포메이션의 경우 스파크는 DAG에 트랜스포메이션을 추가하고 드라이버가 데이터를 요청할 때만 해당 DAG가 실제로 실행된다. 이를 느긋한 계산(lazy evaluation)이라 한다.

* **액션**은 실제로 계산이 수행되는 연산이다.

### 트랜스포메이션

#### 일반 트랜스포메이션

#### 수학/통계 트랜스포메이션

#### 집합 이론/관계형 트랜스포메이션

#### 데이터 구조 기반 트랜스포메이션


### 액션
액션은 코드 블록과 함수를 실행함으로써 데이터가 구체화될 수 있게 생성된 트랜스포메이션의 전체 DAG(Directed Acyclic Graph)를 실행한다.
DAG가 명세한 대로 모든 연산이 실행된다.

* 액션 연산의 두가지 종류
  * 드라이버(Driver): 원격 익스큐터에서 계산을 수행하고 데이터를 다시 드라이버로 가져온다. **<!> 메모리 문제가 있을 수 있다. 신중히 사용해야 한다**
  * 분산(Distributed): 분산 액션으로 클러스터의 노드에서 실행된다.


## 캐싱
* 캐싱(caching)은 스파크에서 계산과 연산을 실행하면서 얻은 데이터를 저장할 수 있다.
* 스파크에서 가장 중요한 기술중 하나다.
* 캐싱은 RDD를 가능한 한 메모리에 저장함으로써 동작한다.
* 충분한 메모리가 없다면 LRU 정책에 따라 정리(eviction)
* 캐시할 데이터가 사용할 수 있는 메모리보다 크다면 메모리 대신 디스크가 사용되기 때문에 성능이 저하될 것이다.
* persist 또는 cache를 사용해 RDD를 캐싱할 수 있다.
  * cache: persist(MEMORY_ONLY)와 동일한 의미다.
  * persist: 메모리나 디스크 또는 둘 다 사용할 수 있다.


## 데이터 로드와 저장

### 데이터 로드

### textFile

### RDD 저장


## 요약

